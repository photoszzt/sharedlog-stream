// Code generated by gotemplate. DO NOT EDIT.

// Package treemap provides a generic key-sorted map. It uses red-black tree under the hood.
// You can use it as a template to generate a sorted map with specific key and value types.
// Iterators are designed after C++.
//
// Example:
//
//     package main
//
//     import "fmt"
//
//     //go:generate gotemplate "github.com/igrmk/treemap" "intStringTreeMap(int, string)"
//
//     func less(x, y int) bool { return x < y }
//
//     func main() {
//         tr := newIntStringTreeMap(less)
//         tr.Set(0, "Hello")
//         tr.Set(1, "World")
//
//         for it := tr.Iterator(); it.Valid(); it.Next() {
//             fmt.Println(it.Key(), it.Value())
//         }
//     }
package state

import "github.com/rs/zerolog/log"

// template type TreeMap(Key, Value)

// Key is a generic key type of the map

// Value is a generic value type of the map

// TreeMap is the red-black tree based map
type BytesTreeMap struct {
	endNode   *nodeBytesTreeMap
	beginNode *nodeBytesTreeMap
	count     uint64
	// Less returns a < b
	Less func(a []byte, b []byte) bool
}

type nodeBytesTreeMap struct {
	right   *nodeBytesTreeMap
	left    *nodeBytesTreeMap
	parent  *nodeBytesTreeMap
	isBlack bool
	key     []byte
	value   []byte
}

// New creates and returns new TreeMap.
// Parameter less is a function returning a < b.
func NewBytesTreeMap(less func(a []byte, b []byte) bool) *BytesTreeMap {
	endNode := &nodeBytesTreeMap{isBlack: true}
	return &BytesTreeMap{beginNode: endNode, endNode: endNode, Less: less}
}

// Len returns total count of elements in a map.
// Complexity: O(1).
func (t *BytesTreeMap) Len() uint64 { return t.count }

// Set sets the value and silently overrides previous value if it exists.
// Complexity: O(log N).
func (t *BytesTreeMap) Set(key []byte, value []byte) {
	parent := t.endNode
	current := parent.left
	less := true
	for current != nil {
		parent = current
		switch {
		case t.Less(key, current.key):
			current = current.left
			less = true
		case t.Less(current.key, key):
			current = current.right
			less = false
		default:
			current.value = value
			return
		}
	}
	x := &nodeBytesTreeMap{parent: parent, value: value, key: key}
	if less {
		parent.left = x
	} else {
		parent.right = x
	}
	if t.beginNode.left != nil {
		t.beginNode = t.beginNode.left
	}
	t.insertFixup(x)
	t.count++
}

// Del deletes the value.
// Complexity: O(log N).
func (t *BytesTreeMap) Del(key []byte) {
	z := t.findNode(key)
	if z == nil {
		return
	}
	if t.beginNode == z {
		if z.right != nil {
			t.beginNode = z.right
		} else {
			t.beginNode = z.parent
		}
	}
	t.count--
	removeNodeBytesTreeMap(t.endNode.left, z)
}

// Clear clears the map.
// Complexity: O(1).
func (t *BytesTreeMap) Clear() {
	t.count = 0
	t.beginNode = t.endNode
	t.endNode.left = nil
}

// Get retrieves a value from a map for specified key and reports if it exists.
// Complexity: O(log N).
func (t *BytesTreeMap) Get(id []byte) ([]byte, bool) {
	node := t.findNode(id)
	if node == nil {
		node = t.endNode
	}
	return node.value, node != t.endNode
}

// Contains checks if key exists in a map.
// Complexity: O(log N)
func (t *BytesTreeMap) Contains(id []byte) bool { return t.findNode(id) != nil }

// Range returns a pair of iterators that you can use to go through all the keys in the range [from, to].
// More specifically it returns iterators pointing to lower bound and upper bound.
// Complexity: O(log N).
func (t *BytesTreeMap) Range(from, to []byte) (ForwardIteratorBytesTreeMap, ForwardIteratorBytesTreeMap) {
	return t.LowerBound(from), t.UpperBound(to)
}

// LowerBound returns an iterator pointing to the first element that is not less than the given key.
// Complexity: O(log N).
func (t *BytesTreeMap) LowerBound(key []byte) ForwardIteratorBytesTreeMap {
	result := t.endNode
	node := t.endNode.left
	if node == nil {
		return ForwardIteratorBytesTreeMap{tree: t, node: t.endNode}
	}
	for {
		if t.Less(node.key, key) {
			if node.right != nil {
				node = node.right
			} else {
				return ForwardIteratorBytesTreeMap{tree: t, node: result}
			}
		} else {
			result = node
			if node.left != nil {
				node = node.left
			} else {
				return ForwardIteratorBytesTreeMap{tree: t, node: result}
			}
		}
	}
}

// UpperBound returns an iterator pointing to the first element that is greater than the given key.
// Complexity: O(log N).
func (t *BytesTreeMap) UpperBound(key []byte) ForwardIteratorBytesTreeMap {
	result := t.endNode
	node := t.endNode.left
	if node == nil {
		return ForwardIteratorBytesTreeMap{tree: t, node: t.endNode}
	}
	for {
		if !t.Less(key, node.key) {
			if node.right != nil {
				node = node.right
			} else {
				return ForwardIteratorBytesTreeMap{tree: t, node: result}
			}
		} else {
			result = node
			if node.left != nil {
				node = node.left
			} else {
				return ForwardIteratorBytesTreeMap{tree: t, node: result}
			}
		}
	}
}

func (t *BytesTreeMap) ReverseRange(from, to []byte) (ReverseIteratorBytesTreeMap, ReverseIteratorBytesTreeMap) {
	return t.ReverseLowerBound(from), t.ReverseUpperBound(to)
}

// ReverseUpperBound returns an reverse iterator pointing to the first element that is lower than the given key.
func (t *BytesTreeMap) ReverseUpperBound(key []byte) ReverseIteratorBytesTreeMap {
	result := t.endNode
	node := t.endNode.left
	if node == nil {
		return ReverseIteratorBytesTreeMap{tree: t, node: t.endNode}
	}
	for {
		if t.Less(node.key, key) { // node.key < key
			result = node
			if node.right != nil {
				node = node.right
			} else {
				return ReverseIteratorBytesTreeMap{tree: t, node: node}
			}
		} else { // node.key >= key
			if node.left != nil {
				node = node.left
			} else {
				return ReverseIteratorBytesTreeMap{tree: t, node: result}
			}
		}
	}
}

// ReverseLowerBound returns an rever iterator pointering to the first element that's lower or equal to the given key
func (t *BytesTreeMap) ReverseLowerBound(key []byte) ReverseIteratorBytesTreeMap {
	result := t.endNode
	node := t.endNode.left
	if node == nil {
		return ReverseIteratorBytesTreeMap{tree: t, node: t.endNode}
	}
	for {
		log.Info().Msgf("key: %v, node.key: %v", key, node.key)
		if !t.Less(key, node.key) { // key >= node.key
			result = node
			if t.Less(node.key, key) { // key > node.key
				if node.right != nil {
					node = node.right
				} else { // already reaches largest
					log.Info().Msg("return from br1")
					return ReverseIteratorBytesTreeMap{tree: t, node: node}
				}
			} else { // key = node.key
				log.Info().Msg("return from br2")
				return ReverseIteratorBytesTreeMap{tree: t, node: node}
			}
		} else { // key < node.key
			if node.left != nil { // try to find one that's smaller
				node = node.left
			} else { // can't find one
				log.Info().Msg("return from br3")
				return ReverseIteratorBytesTreeMap{tree: t, node: result}
			}
		}
	}
}

// Iterator returns an iterator for tree map.
// It starts at the first element and goes to the one-past-the-end position.
// You can iterate a map at O(N) complexity.
// Method complexity: O(1)
func (t *BytesTreeMap) Iterator() ForwardIteratorBytesTreeMap {
	return ForwardIteratorBytesTreeMap{tree: t, node: t.beginNode}
}

// Reverse returns a reverse iterator for tree map.
// It starts at the last element and goes to the one-before-the-start position.
// You can iterate a map at O(N) complexity.
// Method complexity: O(log N)
func (t *BytesTreeMap) Reverse() ReverseIteratorBytesTreeMap {
	node := t.endNode.left
	if node != nil {
		node = mostRightBytesTreeMap(node)
	}
	return ReverseIteratorBytesTreeMap{tree: t, node: node}
}

func (t *BytesTreeMap) findNode(id []byte) *nodeBytesTreeMap {
	current := t.endNode.left
	for current != nil {
		switch {
		case t.Less(id, current.key):
			current = current.left
		case t.Less(current.key, id):
			current = current.right
		default:
			return current
		}
	}
	return nil
}

func mostLeftBytesTreeMap(x *nodeBytesTreeMap) *nodeBytesTreeMap {
	for x.left != nil {
		x = x.left
	}
	return x
}

func mostRightBytesTreeMap(x *nodeBytesTreeMap) *nodeBytesTreeMap {
	for x.right != nil {
		x = x.right
	}
	return x
}

func successorBytesTreeMap(x *nodeBytesTreeMap) *nodeBytesTreeMap {
	if x.right != nil {
		return mostLeftBytesTreeMap(x.right)
	}
	for x != x.parent.left {
		x = x.parent
	}
	return x.parent
}

func predecessorBytesTreeMap(x *nodeBytesTreeMap) *nodeBytesTreeMap {
	if x.left != nil {
		return mostRightBytesTreeMap(x.left)
	}
	for x.parent != nil && x != x.parent.right {
		x = x.parent
	}
	return x.parent
}

func rotateLeftBytesTreeMap(x *nodeBytesTreeMap) {
	y := x.right
	x.right = y.left
	if x.right != nil {
		x.right.parent = x
	}
	y.parent = x.parent
	if x == x.parent.left {
		x.parent.left = y
	} else {
		x.parent.right = y
	}
	y.left = x
	x.parent = y
}

func rotateRightBytesTreeMap(x *nodeBytesTreeMap) {
	y := x.left
	x.left = y.right
	if x.left != nil {
		x.left.parent = x
	}
	y.parent = x.parent
	if x == x.parent.left {
		x.parent.left = y
	} else {
		x.parent.right = y
	}
	y.right = x
	x.parent = y
}

func (t *BytesTreeMap) insertFixup(x *nodeBytesTreeMap) {
	root := t.endNode.left
	x.isBlack = x == root
	for x != root && !x.parent.isBlack {
		if x.parent == x.parent.parent.left {
			y := x.parent.parent.right
			if y != nil && !y.isBlack {
				x = x.parent
				x.isBlack = true
				x = x.parent
				x.isBlack = x == root
				y.isBlack = true
			} else {
				if x != x.parent.left {
					x = x.parent
					rotateLeftBytesTreeMap(x)
				}
				x = x.parent
				x.isBlack = true
				x = x.parent
				x.isBlack = false
				rotateRightBytesTreeMap(x)
				break
			}
		} else {
			y := x.parent.parent.left
			if y != nil && !y.isBlack {
				x = x.parent
				x.isBlack = true
				x = x.parent
				x.isBlack = x == root
				y.isBlack = true
			} else {
				if x == x.parent.left {
					x = x.parent
					rotateRightBytesTreeMap(x)
				}
				x = x.parent
				x.isBlack = true
				x = x.parent
				x.isBlack = false
				rotateLeftBytesTreeMap(x)
				break
			}
		}
	}
}

// nolint: gocyclo
//noinspection GoNilness
func removeNodeBytesTreeMap(root *nodeBytesTreeMap, z *nodeBytesTreeMap) {
	var y *nodeBytesTreeMap
	if z.left == nil || z.right == nil {
		y = z
	} else {
		y = successorBytesTreeMap(z)
	}
	var x *nodeBytesTreeMap
	if y.left != nil {
		x = y.left
	} else {
		x = y.right
	}
	var w *nodeBytesTreeMap
	if x != nil {
		x.parent = y.parent
	}
	if y == y.parent.left {
		y.parent.left = x
		if y != root {
			w = y.parent.right
		} else {
			root = x // w == nil
		}
	} else {
		y.parent.right = x
		w = y.parent.left
	}
	removedBlack := y.isBlack
	if y != z {
		y.parent = z.parent
		if z == z.parent.left {
			y.parent.left = y
		} else {
			y.parent.right = y
		}
		y.left = z.left
		y.left.parent = y
		y.right = z.right
		if y.right != nil {
			y.right.parent = y
		}
		y.isBlack = z.isBlack
		if root == z {
			root = y
		}
	}
	if removedBlack && root != nil {
		if x != nil {
			x.isBlack = true
		} else {
			for {
				if w != w.parent.left {
					if !w.isBlack {
						w.isBlack = true
						w.parent.isBlack = false
						rotateLeftBytesTreeMap(w.parent)
						if root == w.left {
							root = w
						}
						w = w.left.right
					}
					if (w.left == nil || w.left.isBlack) && (w.right == nil || w.right.isBlack) {
						w.isBlack = false
						x = w.parent
						if x == root || !x.isBlack {
							x.isBlack = true
							break
						}
						if x == x.parent.left {
							w = x.parent.right
						} else {
							w = x.parent.left
						}
					} else {
						if w.right == nil || w.right.isBlack {
							w.left.isBlack = true
							w.isBlack = false
							rotateRightBytesTreeMap(w)
							w = w.parent
						}
						w.isBlack = w.parent.isBlack
						w.parent.isBlack = true
						w.right.isBlack = true
						rotateLeftBytesTreeMap(w.parent)
						break
					}
				} else {
					if !w.isBlack {
						w.isBlack = true
						w.parent.isBlack = false
						rotateRightBytesTreeMap(w.parent)
						if root == w.right {
							root = w
						}
						w = w.right.left
					}
					if (w.left == nil || w.left.isBlack) && (w.right == nil || w.right.isBlack) {
						w.isBlack = false
						x = w.parent
						if !x.isBlack || x == root {
							x.isBlack = true
							break
						}
						if x == x.parent.left {
							w = x.parent.right
						} else {
							w = x.parent.left
						}
					} else {
						if w.left == nil || w.left.isBlack {
							w.right.isBlack = true
							w.isBlack = false
							rotateLeftBytesTreeMap(w)
							w = w.parent
						}
						w.isBlack = w.parent.isBlack
						w.parent.isBlack = true
						w.left.isBlack = true
						rotateRightBytesTreeMap(w.parent)
						break
					}
				}
			}
		}
	}
}

// ForwardIterator represents a position in a tree map.
// It is designed to iterate a map in a forward order.
// It can point to any position from the first element to the one-past-the-end element.
type ForwardIteratorBytesTreeMap struct {
	tree *BytesTreeMap
	node *nodeBytesTreeMap
}

// Valid reports if an iterator's position is valid.
// In other words it returns true if an iterator is not at the one-past-the-end position.
func (i ForwardIteratorBytesTreeMap) Valid() bool { return i.node != i.tree.endNode }

// Next moves an iterator to the next element.
// It panics if goes out of bounds.
func (i *ForwardIteratorBytesTreeMap) Next() {
	if i.node == i.tree.endNode {
		panic("out of bound iteration")
	}
	i.node = successorBytesTreeMap(i.node)
}

// Prev moves an iterator to the previous element.
// It panics if goes out of bounds.
func (i *ForwardIteratorBytesTreeMap) Prev() {
	i.node = predecessorBytesTreeMap(i.node)
	if i.node == nil {
		panic("out of bound iteration")
	}
}

// Key returns a key at an iterator's position
func (i ForwardIteratorBytesTreeMap) Key() []byte { return i.node.key }

// Value returns a value at an iterator's position
func (i ForwardIteratorBytesTreeMap) Value() []byte { return i.node.value }

// ReverseIterator represents a position in a tree map.
// It is designed to iterate a map in a reverse order.
// It can point to any position from the one-before-the-start element to the last element.
type ReverseIteratorBytesTreeMap struct {
	tree *BytesTreeMap
	node *nodeBytesTreeMap
}

// Valid reports if an iterator's position is valid.
// In other words it returns true if an iterator is not at the one-before-the-start position.
func (i ReverseIteratorBytesTreeMap) Valid() bool { return i.node != nil }

// Next moves an iterator to the next element in reverse order.
// It panics if goes out of bounds.
func (i *ReverseIteratorBytesTreeMap) Next() {
	if i.node == nil {
		panic("out of bound iteration")
	}
	i.node = predecessorBytesTreeMap(i.node)
}

// Prev moves an iterator to the previous element in reverse order.
// It panics if goes out of bounds.
func (i *ReverseIteratorBytesTreeMap) Prev() {
	if i.node != nil {
		i.node = successorBytesTreeMap(i.node)
	} else {
		i.node = i.tree.beginNode
	}
	if i.node == i.tree.endNode {
		panic("out of bound iteration")
	}
}

// Key returns a key at an iterator's position
func (i ReverseIteratorBytesTreeMap) Key() []byte { return i.node.key }

// Value returns a value at an iterator's position
func (i ReverseIteratorBytesTreeMap) Value() []byte { return i.node.value }
